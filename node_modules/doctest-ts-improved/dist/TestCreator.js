"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const UnitTest_1 = require("./UnitTest");
const ts = require("typescript");
const ExtractComments_1 = require("./ExtractComments");
const fs = require("fs");
const path = require("path");
/**
 * Responsible for creating a '.doctest.ts'-file
 */
class TestCreator {
    constructor(originalFilepath) {
        this._originalFilepath = originalFilepath;
        if (originalFilepath.includes('doctest')) {
            throw "Not creating a doctest for a file which already is a doctest";
        }
    }
    static exposePrivates(s) {
        const ast = ts.createSourceFile('_.ts', s, ts.ScriptTarget.Latest);
        const transformer = (context) => (rootNode) => {
            function visit(node) {
                if (node.kind === ts.SyntaxKind.PrivateKeyword || node.kind == ts.SyntaxKind.ProtectedKeyword) {
                    return ts.createModifier(ts.SyntaxKind.PublicKeyword);
                }
                return ts.visitEachChild(node, visit, context);
            }
            return ts.visitNode(rootNode, visit);
        };
        const transformed = ts.transform(ast, [transformer]).transformed[0];
        const pwoc = ts.createPrinter({ removeComments: false });
        return pwoc.printNode(ts.EmitHint.Unspecified, transformed, ast);
    }
    static testCode(tests) {
        const code = [];
        const exportedTests = new Set();
        function show(s) {
            return JSON.stringify(s);
        }
        function emit(test, indent = "") {
            if (exportedTests.has(test)) {
                return;
            }
            const testCode = "\n" + test.generateCode();
            code.push(testCode.replace(/\n/g, "\n" + indent));
            exportedTests.add(test);
        }
        function emitAllForFunction(functionname, indent) {
            tests.filter(t => t.context.functionname === functionname).forEach(c => emit(c, "    " + indent));
        }
        function emitAllForClass(classname, indent) {
            const forClass = tests.filter(t => t.context.classname === classname);
            for (const test of forClass) {
                if (exportedTests.has(test)) {
                    continue;
                }
                if (test.context.functionname !== undefined) {
                    code.push(indent + "describe(" + show(test.context.functionname) + ", () => {");
                    emitAllForFunction(test.context.functionname, "    " + indent);
                    code.push(indent + "})");
                }
            }
            emitAllForFunction(undefined, indent);
        }
        for (const test of tests) {
            if (exportedTests.has(test)) {
                continue;
            }
            if (test.context.classname !== undefined) {
                code.push("describe(" + show(test.context.classname) + ", () => {");
                emitAllForClass(test.context.classname, "    ");
                code.push("})");
            }
        }
        emitAllForClass(undefined, "");
        return code;
    }
    /**
     * Creates a new file with the doctests.
     *
     * Returns the number of found tests
     */
    createTest() {
        const file = this._originalFilepath;
        const _a = path.parse(file), { base, ext } = _a, u = __rest(_a, ["base", "ext"]);
        const buffer = fs.readFileSync(file, { encoding: 'utf8' });
        const comments = new ExtractComments_1.default(file, buffer).getComments();
        const tests = UnitTest_1.default.FromComments(comments);
        const outfile = path.format(Object.assign(Object.assign({}, u), { ext: '.doctest' + ext }));
        if (tests.length == 0) {
            return 0;
        }
        const code = [];
        const imports = new Set();
        for (const test of tests) {
            test.getImports().forEach(i => imports.add(i));
        }
        // Add imports needed by the tests
        code.push(...Array.from(imports));
        // Adds the original code where the private keywords are removed
        code.push(TestCreator.exposePrivates(buffer));
        // At last, we add all the doctests
        code.push(...TestCreator.testCode(tests));
        fs.writeFileSync(outfile, code.join("\n"));
        return tests.length;
    }
}
exports.default = TestCreator;
//# sourceMappingURL=TestCreator.js.map