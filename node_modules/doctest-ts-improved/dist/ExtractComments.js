"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const tsserverlibrary_1 = require("typescript/lib/tsserverlibrary");
/**
 * Responsible for extracting the testfiles from the .ts files
 *
 */
class ExtractComments {
    constructor(filepath, code) {
        this.results = [];
        this.code = code;
        const ast = ts.createSourceFile('_.ts', code, ts.ScriptTarget.Latest);
        this.traverse(ast, { filepath: filepath });
    }
    /**
     * Gets the actual comments and their context.
     */
    getComments() {
        return this.results;
    }
    getLineNumber(pos) {
        let line = 0;
        for (let i = 0; i < pos; i++) {
            if (this.code[i] === "\n") {
                line++;
            }
        }
        return line;
    }
    registerComment(context, comment, position) {
        if (comment === undefined) {
            return;
        }
        context = Object.assign(Object.assign({}, context), { linenumber: this.getLineNumber(position) });
        if (typeof comment === "string") {
            this.results.push({ comment: comment || '', context });
        }
        else {
            comment.forEach(jsDocComment => {
                this.results.push({ comment: jsDocComment.text || '', context });
            });
        }
    }
    traverse(node, context) {
        if (tsserverlibrary_1.SyntaxKind.ClassDeclaration === node.kind) {
            context = Object.assign(Object.assign({}, context), { classname: node["name"].escapedText });
        }
        const jsdocs = node.jsDoc || [];
        if (jsdocs.length > 0) {
            let declName = undefined;
            try {
                declName = node.name.escapedText;
            }
            catch (e) {
                try {
                    const decls = node.declarationList.declarations;
                    if (decls.length == 1) {
                        declName = decls[0].name.escapedText || null;
                    }
                }
                catch (e) {
                    declName = ts.isConstructorDeclaration(node) ? 'constructor' : undefined;
                }
            }
            context = Object.assign(Object.assign({}, context), { functionname: declName });
            jsdocs.forEach((doc) => {
                this.registerComment(context, doc.comment, doc.pos);
                // A part of the comment might be in the tags; we simply add those too and figure out later if they contain doctests
                const tags = doc.tags;
                if (tags !== undefined) {
                    tags.forEach(tag => {
                        this.registerComment(context, tag.comment, tag.pos);
                    });
                }
            });
        }
        ts.forEachChild(node, n => this.traverse(n, context));
    }
}
exports.default = ExtractComments;
//# sourceMappingURL=ExtractComments.js.map